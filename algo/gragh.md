# 图

## 概念

- 顶点
- 边
- 度

## 分类
- 有向图
入度和出度

- 无向图

- 带权图：每条边都有一个权重

## 内存中的存储

### 邻接矩阵
使用一个二维数组实现，对于无向图，如果顶点 i 与 j 之间有边，就将 A[i][j]、A[j][i] 标记为 1；对于无向图，如果顶点 i 指向 j, 就将 A[i][j]标记为1；对于带权图，数组中就存储相应的权重
缺点：
- 存储稀疏图时，比较浪费空间
优点：
- 存储方式简单，获取两点间的关系时很高效
- 便于计算，求最短路径的 [Floyd-Warshall 算法](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95)利用循环相乘若干次得到


### 邻接表
每个顶点对应一条链表（链表也可以改造成其他时间效率更快的数据结构，如红黑树、跳表、散列表、有序动态数组(?)）


### 微博用户关注关系

使用邻接表和逆邻接表
因为我们需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是 O(logn)，空间复杂度上稍高，是 O(n)。最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。
如果对于小规模的数据，比如社交网络中只有几万、几十万个用户，我们可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，我们就无法全部存储在内存中了。这个时候该怎么办呢？
我们可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。你可以看下面这幅图，我们在机器 1 上存储顶点 1，2，3 的邻接表，在机器 2 上，存储顶点 4，5 的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。



## 基于图的搜索算法
什么是“搜索”算法？我们知道，算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如今天要讲的两种最简单、最“暴力”的深度优先、广度优先搜索，还有 A*、IDA* 等启发式搜索算法。


## BFS

## DFS

leetcode:
