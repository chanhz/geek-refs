# 创建模式

## Builder Pattern
将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.
通俗来讲，例如，创造一辆小轿车，需要 4 个轮子、1个方向盘、4 个座位、汽油发动机；创造一辆摩托车，需要 2 个轮子、0 个方向盘，1 排座位、汽油马达。现在有一种强大的构造器，既可以构造小轿车，又能构造摩托车，此时，同样的构建过程，通过不通得构造模型和参数，可以构造出不同表示的对象


## Factory Method
使一个类的实例化延迟到其子类, 定义一个用于创建对象的接口, 让子类决定将哪一个类实例化。

例如，购物时扣款方式可以选择现金余额或信用卡额度支付，付款时，先定义一个扣款接口，再实现现金支付和信用卡支付的函数，实现该支付的接口。

## Object Pool 对象/线程池
根据需求将预测的对象保存到channel中， 用于对象的生成成本大于维持成本。
将任务使用一个对象来描述，并将其塞到一个队列中，消费端从队列中消费，处理任务


## singleton 单例
单例模式是最简单的设计模式之一, 保证一个类仅有一个实例, 并提供一个全局的访问接口

Golang 中使用 sync.Once 原语来 Do(初始化)，保证初始化只进行一次。



## 生成器模式 Generator
生成器模式可以允许使用者在生成要使用的下一个值时与生成器并行运行

和 Python 的 `yield` 格外相似，  
```
func Count(start, end int) <-chan int {
	ch := make(chan int)

	go func(ch chan int) {
		for i := start; i <= end; i ++ {
			ch <- i
		}
		close(ch)
	}(ch)

	return ch
}
```

## 抽象工厂模式 Abstract Factory

提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类，而由类实现接口相应的方法。


## 原型模式 Prototype Pattern

复制一个已存在的实例(?这也算模式?)

# 结构模式

## 装饰模式 Decorator Pattern

装饰模式**使用对象组合的方式动态改变或增加对象行为**， 在原对象的基础上增加功能

换句话说，装饰模式就是将对象组合，并借助组合对象实现的方法来表达新对象的行为，是一种结构体复用的设计模式。


## 代理模式 Proxy Pattern

代理模式用于**延迟处理操作或者在进行实际操作前后对真实对象**进行其它处理。

具体做法：
创建一个代理结构体，来包裹真实对象，对真实对象的操作进行拦截和特殊处理。

## 

