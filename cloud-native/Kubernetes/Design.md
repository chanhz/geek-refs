## 分层架构
- 核心层：对外提供 API 构建高层应用，对内提供插件式应用执行环境
- 应用层：部署(RC,RS,SS,CJ)和路由(服务发现，DNS解析)
- 管理层: 系统度量，自动化以及策略管理
- 接口层： kubectl 命令工具，客户端 SDK 以及集群联邦
- 生态系统：接口层之上容器集群管理调度生态系统
  - 外部：日志、监控、配置管理、CI/CD、Workflow、 FaaS、 OTS、 ChatOps
  - 内部：CRI、CNI、 CVI、镜像仓库、Cloud Provider、集群自身的配置和管理

## API 设计原则
1. 所有 API 应该是声明式的，而不是命令式的，保证重复操作的效果是一样的
2. API 对象是彼此互补而且是可组合的
...

## Kubernetes 核心技术概念和 API 对象
API对象是Kubernetes集群中的管理操作单元。Kubernetes集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。

每个API对象都有3大类属性：元数据metadata、规范spec和状态status。元数据是用来标识API对象的，每个对象都至少有3个元数据：namespace，name和uid；除此以外还有各种各样的标签labels用来标识和匹配不同的对象，例如用户可以用标签env来标识区分不同的服务部署环境，分别用env=dev、env=testing、env=production来标识开发、测试、生产的不同服务。

Kubernetes 中所有的配置都是通过 API 对象的 spec 去设置的，也就是用户通过配置系统的理想状态来改变系统，这是 Kubernetes 重要设计理念之一，即所有的操作都是声明式（ Declarative ）的而不是命令式（Imperative）的。声明式操作在分布式系统中的好处是稳定，不怕丢操作或运行多次，例如设置副本数为3的操作运行多次也还是一个结果，而给副本数加1的操作就不是声明式的。

## Pod

Pod 是集群中运行应用或服务的最小单元，Pod 支持多容器。
一个 Pod 中的多个容器可以共享网络地址和文件系统，可以通过进程间通信和文件共享的方式组合服务。 **Pod 对多容器的支持是 K8 最基础的设计理念**。

举个栗子：

一个操作系统发行版的软件仓库的 WEB 服务，由一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步。这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；**这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。**

Pod 是 Kubernetes 集群中所有业务类型的基础，可以看作运行在 K8 中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前 K8 中的业务主要可以分为：
- 长期伺服型（long-running）- Deployment
- 批处理型（batch）- Job
- 节点后支撑型（node-daemon） - DaemonSet
- 有状态应用型（stateful-application）- StatefulSet

## 副本控制器(Replication Controller, RC)
RC 是 Kubernetes 集群中最早的保证 Pod 高可用的 API 对象。通过监控运行中的 Pod 来保证集群中运行指定数目的 Pod 副本。RC 可以发挥它高可用的能力，保证永远有 1 个 Pod 在运行。RC 是 Kubernetes 较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的 Web 服务。

## 副本集（Relica Set，RS）
RS 是新一代 RC，提供同样的高可用能力。RS 后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为 Deployment 的理想状态参数使用。

## 部署（Deployment）
部署表示对 K8 集群的一次更新操作，是一个比 RS 应用模式更广的 API 对象，可以是创建新的服务、更新服务、滚动升级一个服务。滚动升级一个服务，实际是创建一个新的 RS， 然后逐渐将新 RS 中副本数量增加到理想的状态，将旧 RS 中的副本数减小到 0 的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的Deployment来描述。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。 

## 服务 (Service)
RC、 RS 和 Deployment 保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。
一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。**要稳定地提供服务需要服务发现和负载均衡能力**。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在K8集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在Kubernetes集群中微服务的负载均衡是由Kube-proxy实现的。**Kube-proxy 是Kubernetes集群内的一个分布式代理服务器，在Kubernetes 的每个 Node 上都有一个**；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解决反向代理的负载均衡和高可用问题。